/*** PATCH: Fix PDF font consistency + stop footer overlap (safe & minimal)
 * Goal: Reset body font after every page add, and keep text clear of the footer.
 ***********************************************************************************************/

window.YBG_PDF = window.YBG_PDF || {};

(function (ns) {
  // --- Layout & typography tokens (keep aligned with template) ---
  const MARGINS = { top: 56, right: 56, bottom: 68, left: 56 }; // bottom ↑ to protect footer
  const BODY    = { font: "helvetica", weight: "normal", size: 12, color: [50, 50, 50] };

  // Apply standard body style (call whenever you start writing on a page)
  ns.applyBodyStyle = function applyBodyStyle(doc) {
    doc.setFont(BODY.font, BODY.weight);
    doc.setFontSize(BODY.size);
    doc.setTextColor(...BODY.color);
  };

  // Should we break before drawing the next line? (prevents footer overlap)
  ns.shouldBreakBeforeLine = function shouldBreakBeforeLine(doc, cursorY, lineHeight) {
    const pageH = doc.internal.pageSize.getHeight();
    return cursorY > (pageH - MARGINS.bottom - lineHeight);
  };

  // Safe page add: always reset fonts and redraw header
  ns.safeAddPage = function safeAddPage(doc, currentPageNumber, drawHeaderFn) {
    const nextPage = currentPageNumber + 1;
    doc.addPage();
    ns.applyBodyStyle(doc);          // <- reset font/size/weight every new page
    if (typeof drawHeaderFn === "function") drawHeaderFn(nextPage);
    return nextPage;
  };

  // Safer footer (use in your export finalize loop)
  ns.drawFooter = function drawFooter(doc, pageNumber, pageCount) {
    const h = doc.internal.pageSize.getHeight();
    doc.setFont("helvetica", "normal");
    doc.setFontSize(9);
    doc.setTextColor(110, 110, 110);
    const footer = `Generated by CompliPilot · YourBizGuru.com   Page ${pageNumber} of ${pageCount}`;
    // place ~24pt above bottom; text stays clear of content due to bottom margin
    doc.text(footer, MARGINS.left, h - 24);
    
    // Add disclaimer below main footer text
    doc.setFontSize(7);
    doc.setTextColor(130, 130, 130);
    const disclaimer = "Disclaimer: For informational purposes only. Not legal, tax, or financial advice.";
    doc.text(disclaimer, MARGINS.left, h - 18);
  };

  // Expose margins for callers
  ns.PDF_MARGINS = MARGINS;
})(window.YBG_PDF);

/* public/pdf-export.js
   YBG PDF Export - Production Quality Implementation
   - Consistent typography across all pages
   - Clean pagination with proper word wrapping
   - Correct timestamp-based result filtering
   - No footer/header overlap
*/

(() => {
  'use strict';

  // ---- jsPDF Lazy Loader ---------------------------------------------------
  const loadJsPDF = (() => {
    let cached;
    return async () => {
      if (cached) return cached;
      if (window.jspdf?.jsPDF) {
        cached = window.jspdf.jsPDF;
        return cached;
      }
      const src = "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js";
      await new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = src;
        script.onload = resolve;
        script.onerror = () => reject(new Error("Failed to load jsPDF"));
        document.head.appendChild(script);
      });
      cached = window.jspdf.jsPDF;
      return cached;
    };
  })();

  // ---- Constants (A4 Portrait) ---------------------------------------------
  const PAGE = {
    width: 210,  // mm
    height: 297  // mm
  };

  const MARGINS = {
    top: 20,
    bottom: 20,
    left: 16,
    right: 16
  };

  const HEADER = {
    height: 18,      // Total header area height
    iconSize: 10,    // Icon diameter
    iconRing: 0.8    // Ring thickness
  };

  const FOOTER = {
    height: 15       // Total footer area height including text
  };

  // Safe content area calculation
  const CONTENT = {
    top: MARGINS.top + HEADER.height,
    bottom: PAGE.height - MARGINS.bottom - FOOTER.height,
    left: MARGINS.left,
    right: PAGE.width - MARGINS.right,
    width: PAGE.width - MARGINS.left - MARGINS.right
  };
  CONTENT.height = CONTENT.bottom - CONTENT.top;

  // ---- Typography Tokens (Global, Applied Per Page) ------------------------
  const TYPOGRAPHY = {
    fontFamily: "helvetica",
    
    // Sizes
    bodySize: 11,
    h2Size: 13,
    h3Size: 11,
    footerSize: 9,
    headerTitleSize: 12,
    
    // Line heights
    lineHeight: 5.5,  // mm (approx 1.35x for 11pt)
    h2LineHeight: 6.5,
    h3LineHeight: 5.8,
    paragraphSpacing: 3.5,
    
    // Colors (RGB arrays for jsPDF)
    colorBody: [51, 51, 51],      // #333
    colorHeading: [17, 17, 17],   // #111  
    colorMeta: [102, 102, 102],   // #666
    colorAccent: [79, 195, 247]   // Brand blue
  };

  // ---- Global Typography Application ---------------------------------------
  function applyGlobalTypography(doc) {
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(TYPOGRAPHY.bodySize);
    doc.setTextColor(...TYPOGRAPHY.colorBody);
    doc.setLineWidth(0.2);
  }

  // ---- Toolkit Configuration -----------------------------------------------
  function getToolkitName() {
    return window.currentToolkitName || "CompliPilot";
  }

  function getToolkitIcon() {
    return window.currentToolkitIcon || "/complipilot-logo.png";
  }

  // ---- Image Loading -------------------------------------------------------
  async function loadImageAsDataURL(url) {
    if (!url) return null;
    try {
      const response = await fetch(url);
      if (!response.ok) return null;
      const blob = await response.blob();
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => resolve(null);
        reader.readAsDataURL(blob);
      });
    } catch {
      return null;
    }
  }

  // ---- Header Drawing ------------------------------------------------------
  function drawHeader(doc, pageNum, iconDataUrl) {
    const x = MARGINS.left;
    const y = MARGINS.top;
    
    // CompliPilot logo with proper aspect ratio (square logo 1015x1001 = 1:1)
    const logoSize = 12;  // mm - square logo
    
    if (iconDataUrl) {
      try {
        const logoX = x;
        const logoY = y + 1;
        
        // Draw square logo
        doc.addImage(iconDataUrl, "PNG", logoX, logoY, logoSize, logoSize, "", "FAST");
      } catch (e) {
        // Silent fail for logo
      }
    }
    
    // Title
    doc.setFont(TYPOGRAPHY.fontFamily, "bold");
    doc.setFontSize(TYPOGRAPHY.headerTitleSize);
    doc.setTextColor(...TYPOGRAPHY.colorHeading);
    doc.text(getToolkitName(), x + logoSize + 4, y + 7);
    
    // Date/time
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(9);
    doc.setTextColor(...TYPOGRAPHY.colorMeta);
    const now = new Date();
    const dateStr = `${now.toLocaleDateString()} • ${now.toLocaleTimeString()}`;
    doc.text(dateStr, x + logoSize + 4, y + 12);
    
    // Add subtle brand-colored divider line below header
    const dividerY = y + 15;  // Position between timestamp and content
    doc.setDrawColor(79, 195, 247); // Light blue brand color
    doc.setLineWidth(0.3);
    doc.line(CONTENT.left, dividerY, CONTENT.right, dividerY);
    
    // Reset to body typography
    applyGlobalTypography(doc);
  }

  // ---- Footer Drawing ------------------------------------------------------
  async function drawFooter(doc, pageNum, totalPages) {
    const mainFooterY = PAGE.height - MARGINS.bottom - 12;
    const disclaimerY = PAGE.height - MARGINS.bottom - 4;
    
    // Faint divider line above footer
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.15);
    doc.line(CONTENT.left, CONTENT.bottom + 6, CONTENT.right, CONTENT.bottom + 6);
    
    // Main footer row
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(TYPOGRAPHY.footerSize);
    doc.setTextColor(...TYPOGRAPHY.colorMeta);
    
    // Left side: Text only (no logo)
    doc.text("Generated by CompliPilot · YourBizGuru.com", CONTENT.left, mainFooterY);
    
    // Right side: "Page X of Y"
    const pageText = `Page ${pageNum} of ${totalPages}`;
    const pageWidth = doc.getTextWidth(pageText);
    doc.text(pageText, CONTENT.right - pageWidth, mainFooterY);
    
    // Disclaimer below (small, muted)
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(7); // Smaller than footer size
    doc.setTextColor(120, 120, 120); // More muted gray
    const disclaimer = "Disclaimer: For informational purposes only. Not legal, tax, or financial advice.";
    const disclaimerWidth = doc.getTextWidth(disclaimer);
    const disclaimerX = (CONTENT.left + CONTENT.right - disclaimerWidth) / 2; // Center the disclaimer
    doc.text(disclaimer, disclaimerX, disclaimerY);
    
    // Reset to body typography
    applyGlobalTypography(doc);
  }

  // ---- Text Processing -----------------------------------------------------
  function parseContent(text) {
    if (!text) return [];
    
    const lines = text.split(/\r?\n/);
    const blocks = [];
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('## ')) {
        blocks.push({
          type: 'h2',
          text: trimmed.substring(3).trim()
        });
      } else if (trimmed.startsWith('### ')) {
        blocks.push({
          type: 'h3', 
          text: trimmed.substring(4).trim()
        });
      } else if (trimmed.startsWith('---')) {
        blocks.push({
          type: 'separator',
          text: ''
        });
      } else if (trimmed.length > 0) {
        // Check if this is a metadata line (key: value pattern near the start)
        const isMetadata = blocks.length < 15 && // Only in first few lines
          (trimmed.match(/^(Generated|Entity|Type|Jurisdiction|Filing|Deadline):\s*.+/) ||
           trimmed.startsWith('**Generated:'));
        
        blocks.push({
          type: isMetadata ? 'metadata' : 'paragraph',
          text: line  // Keep original spacing
        });
      } else {
        blocks.push({
          type: 'blank',
          text: ''
        });
      }
    }
    
    return blocks;
  }

  // ---- Text Cleaning -------------------------------------------------------
  function cleanMarkdown(text) {
    // Remove markdown bold markers (**text** or __text__)
    return text.replace(/\*\*(.+?)\*\*/g, '$1').replace(/__(.+?)__/g, '$1');
  }

  // ---- Word Wrapping Algorithm ---------------------------------------------
  function wrapText(doc, text, maxWidth, fontSize) {
    doc.setFontSize(fontSize);
    
    // Clean markdown markers before wrapping
    const cleanText = cleanMarkdown(text);
    
    const words = cleanText.split(/\s+/);
    const lines = [];
    let currentLine = '';
    
    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = doc.getTextWidth(testLine);
      
      if (testWidth > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines.length > 0 ? lines : [''];
  }

  // ---- Content Writing with Pagination ------------------------------------
  class PDFWriter {
    constructor(doc, iconDataUrl) {
      this.doc = doc;
      this.iconDataUrl = iconDataUrl;
      this.pageNum = 1;
      this.yPosition = CONTENT.top;
      this.totalPages = 1;
    }
    
    needsNewPage(requiredHeight) {
      return window.YBG_PDF.shouldBreakBeforeLine(this.doc, this.yPosition, requiredHeight);
    }
    
    addNewPage() {
      this.totalPages++;
      this.pageNum = window.YBG_PDF.safeAddPage(this.doc, this.pageNum, (pageNum) => {
        drawHeader(this.doc, pageNum, this.iconDataUrl);
      });
      this.yPosition = window.YBG_PDF.PDF_MARGINS.top;
    }
    
    writeBlock(block) {
      let fontSize = TYPOGRAPHY.bodySize;
      let lineHeight = TYPOGRAPHY.lineHeight;
      let isBold = false;
      let textColor = TYPOGRAPHY.colorBody;
      
      // Configure style based on block type
      switch (block.type) {
        case 'h2':
          fontSize = TYPOGRAPHY.h2Size;
          lineHeight = TYPOGRAPHY.h2LineHeight;
          isBold = true;
          textColor = TYPOGRAPHY.colorHeading;
          // Add space before heading
          if (this.yPosition > CONTENT.top + 10) {
            this.yPosition += TYPOGRAPHY.paragraphSpacing;
          }
          
          // Add brand-colored left border accent for h2
          this.doc.setDrawColor(79, 195, 247); // Light blue brand color
          this.doc.setLineWidth(0.8);
          const borderHeight = lineHeight * 0.8;
          this.doc.line(
            CONTENT.left - 3,
            this.yPosition - borderHeight * 0.3,
            CONTENT.left - 3,
            this.yPosition + borderHeight * 0.7
          );
          break;
          
        case 'h3':
          fontSize = TYPOGRAPHY.h3Size;
          lineHeight = TYPOGRAPHY.h3LineHeight;
          isBold = true;
          textColor = TYPOGRAPHY.colorHeading;
          // Add space before heading
          if (this.yPosition > CONTENT.top + 10) {
            this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.8;
          }
          break;
          
        case 'metadata':
          fontSize = 9;
          lineHeight = 4.5;
          textColor = TYPOGRAPHY.colorMeta;
          // Remove ** markers for bold metadata
          block.text = block.text.replace(/\*\*/g, '');
          isBold = block.text.includes('Generated:');
          break;
          
        case 'separator':
          // Check space for separator
          if (this.needsNewPage(10)) {
            this.addNewPage();
          }
          this.yPosition += 5;
          this.doc.setDrawColor(230, 230, 230);
          this.doc.setLineWidth(0.3);
          this.doc.line(CONTENT.left, this.yPosition, CONTENT.right, this.yPosition);
          this.yPosition += 5;
          return;
          
        case 'blank':
          this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.5;
          return;
      }
      
      // Wrap text
      const lines = wrapText(this.doc, block.text, CONTENT.width, fontSize);
      
      // Calculate required height
      const blockHeight = lines.length * lineHeight;
      
      // Check for widows/orphans (keep at least 2 lines together)
      if (lines.length > 1 && this.needsNewPage(blockHeight)) {
        // If we can fit at least 2 lines, do it; otherwise new page
        const minLines = Math.min(2, lines.length);
        const minHeight = minLines * lineHeight;
        
        if (!this.needsNewPage(minHeight)) {
          // Write first few lines on current page
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (let i = 0; i < minLines; i++) {
            this.doc.text(lines[i], CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
          
          // Move to new page for remaining lines
          this.addNewPage();
          
          // Write remaining lines
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (let i = minLines; i < lines.length; i++) {
            this.doc.text(lines[i], CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
        } else {
          // Move everything to new page
          this.addNewPage();
          
          // Write all lines
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (const line of lines) {
            this.doc.text(line, CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
        }
      } else {
        // Write on current page
        this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
        this.doc.setFontSize(fontSize);
        this.doc.setTextColor(...textColor);
        
        for (const line of lines) {
          if (this.needsNewPage(lineHeight)) {
            this.addNewPage();
            this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
            this.doc.setFontSize(fontSize);
            this.doc.setTextColor(...textColor);
          }
          
          this.doc.text(line, CONTENT.left, this.yPosition);
          this.yPosition += lineHeight;
        }
      }
      
      // Add paragraph spacing after block
      if (block.type === 'paragraph') {
        this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.6;
      } else if (block.type === 'metadata') {
        this.yPosition += 1; // Minimal spacing for compact metadata
      }
      
      // Reset typography
      applyGlobalTypography(this.doc);
    }
    
    finalize() {
      // Draw footers on all pages (no logo in footer)
      for (let i = 1; i <= this.totalPages; i++) {
        this.doc.setPage(i);
        drawFooter(this.doc, i, this.totalPages);
      }
    }
  }

  // ---- Result Collection (Match YBGToolkit storage) ------------------------
  function getToolkitStorageKey() {
    // Match the exact same logic as YBGToolkit.getStorageKey()
    const toolkitName = getToolkitName().toLowerCase().replace(/\s+/g, '_');
    return `ybg_toolkit_results_${toolkitName}`;
  }

  function collectResults() {
    // Get results from localStorage using the same key as YBGToolkit
    const storageKey = getToolkitStorageKey();
    
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          console.log('PDF Export: Retrieved', parsed.length, 'results from storage:', storageKey);
          return parsed;
        }
      }
    } catch (e) {
      console.error('PDF Export: Error parsing stored results:', e);
    }
    
    console.log('PDF Export: No results found in storage key:', storageKey);
    return [];
  }

  // ---- Main Export Functions -----------------------------------------------
  async function exportSingleResult(text, resultTitle) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style for consistent typography
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw first page header
    drawHeader(doc, 1, iconDataUrl);
    
    // Parse and write content
    const blocks = parseContent(text);
    
    if (blocks.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        text: 'No content available.'
      });
    } else {
      for (const block of blocks) {
        writer.writeBlock(block);
      }
    }
    
    // Finalize (add footers)
    writer.finalize();
    
    // Generate filename
    const date = new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const safeName = getToolkitName().replace(/[^a-zA-Z0-9]/g, '');
    const filename = `CompliPilot_${yyyy}-${mm}-${dd}_Report.pdf`;
    
    doc.save(filename);
  }

  async function exportMultipleResults(mode = 'all') {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style for consistent typography
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw first page header
    drawHeader(doc, 1, iconDataUrl);
    
    // Collect results from storage
    let results = collectResults();
    
    console.log('PDF Export: Collected', results.length, 'results for mode:', mode);
    
    if (results.length > 0) {
      // Sort by timestamp (oldest to newest for proper chronological order)
      results.sort((a, b) => {
        const timestampA = new Date(a.timestamp).getTime();
        const timestampB = new Date(b.timestamp).getTime();
        return timestampA - timestampB;
      });
      
      // Filter based on mode
      if (mode === 'latest') {
        results = [results[results.length - 1]]; // Take only the most recent
        console.log('PDF Export: Using latest result only');
      }
    }
    
    // Write results
    if (results.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        text: 'No results available.'
      });
    } else {
      results.forEach((result, index) => {
        // Add separator between results (except first)
        if (index > 0) {
          writer.writeBlock({ type: 'separator', text: '' });
        }
        
        // Result header
        const headerText = mode === 'latest' ? 
          'Latest Result' : 
          `Result ${index + 1}`;
        
        writer.writeBlock({
          type: 'h2',
          text: `${headerText} - ${result.displayTime || new Date(result.timestamp).toLocaleString()}`
        });
        
        // Prompt if available
        if (result.prompt) {
          writer.writeBlock({
            type: 'h3',
            text: 'Request'
          });
          writer.writeBlock({
            type: 'paragraph',
            text: result.prompt
          });
        }
        
        // Result content
        if (result.result) {
          writer.writeBlock({
            type: 'h3',
            text: 'Response'
          });
          
          // Parse the result text for any markdown formatting
          const contentBlocks = parseContent(result.result);
          for (const block of contentBlocks) {
            writer.writeBlock(block);
          }
        }
      });
    }
    
    // Finalize (add footers)
    writer.finalize();
    
    // Generate filename based on mode
    const date = new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const safeName = getToolkitName().replace(/[^a-zA-Z0-9]/g, '');
    
    const suffix = mode === 'latest' ? 'Latest_Result' : 'All_Results';
    const filename = `CompliPilot_${yyyy}-${mm}-${dd}_${suffix}.pdf`;
    
    doc.save(filename);
  }

  // ---- Public API ----------------------------------------------------------
  window.exportResultToPDF = function(text) {
    // Single result export (from Download button)
    return exportSingleResult(text || '');
  };

  // Helper: Convert HTML to markdown-like text for PDF rendering
  function htmlToMarkdown(html) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    let markdown = '';
    
    function processNode(node) {
      // Text nodes
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) markdown += text + ' ';
        return;
      }
      
      // Element nodes
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        
        // Special handling for metadata sections
        if (node.classList && node.classList.contains('pdf-header')) {
          // Extract Generated line and checksum
          const tinyDiv = node.querySelector('.tiny');
          if (tinyDiv) {
            markdown += '\n**' + tinyDiv.textContent.trim() + '**\n\n';
          }
          return;
        }
        
        if (node.classList && node.classList.contains('doc-meta')) {
          // Format metadata as a clean table-like structure
          const metaItems = node.querySelectorAll('div');
          for (const item of metaItems) {
            const text = item.textContent.trim();
            if (text) {
              markdown += text + '\n';
            }
          }
          markdown += '\n';
          return;
        }
        
        switch (tagName) {
          case 'h2':
            markdown += '\n## ' + node.textContent.trim() + '\n\n';
            break;
          
          case 'h3':
            markdown += '\n### ' + node.textContent.trim() + '\n\n';
            break;
          
          case 'hr':
            markdown += '\n---\n\n';
            break;
          
          case 'p':
          case 'div':
            // Process children first
            for (const child of node.childNodes) {
              processNode(child);
            }
            markdown += '\n';
            break;
          
          case 'ul':
            for (const li of node.querySelectorAll(':scope > li')) {
              markdown += '• ' + li.textContent.trim() + '\n';
            }
            markdown += '\n';
            break;
          
          case 'ol':
            let index = 1;
            for (const li of node.querySelectorAll(':scope > li')) {
              markdown += `${index}. ` + li.textContent.trim() + '\n';
              index++;
            }
            markdown += '\n';
            break;
          
          case 'table':
            // Convert HTML table to text representation
            const rows = node.querySelectorAll('tr');
            for (const row of rows) {
              const cells = row.querySelectorAll('th, td');
              const cellTexts = Array.from(cells).map(cell => cell.textContent.trim());
              markdown += cellTexts.join(' | ') + '\n';
            }
            markdown += '\n';
            break;
          
          case 'strong':
          case 'b':
            markdown += '**' + node.textContent.trim() + '**';
            break;
          
          case 'em':
          case 'i':
            markdown += '*' + node.textContent.trim() + '*';
            break;
          
          case 'br':
            markdown += '\n';
            break;
          
          default:
            // For unhandled tags, process children
            for (const child of node.childNodes) {
              processNode(child);
            }
            break;
        }
      }
    }
    
    // Process all top-level children
    for (const child of tempDiv.childNodes) {
      processNode(child);
    }
    
    return markdown.trim();
  }

  window.exportAllResultsToPDF = function(resultsArray, options = {}) {
    // NEW: Handle HTML-based export from unified renderer
    if (Array.isArray(resultsArray) && resultsArray.length > 0 && resultsArray[0]?.html) {
      const item = resultsArray[0];
      const htmlContent = item.html;
      
      // Convert HTML to markdown-like text for PDF rendering (preserves structure)
      const markdownContent = htmlToMarkdown(htmlContent);
      
      // Use provided fileName or generate default
      const customFilename = item.fileName || `CompliPilot_${Date.now()}.pdf`;
      
      // Export with custom filename handling
      return exportSingleResultWithFilename(markdownContent, customFilename);
    }
    
    // Legacy: array of strings
    if (Array.isArray(resultsArray) && resultsArray.length > 0 && typeof resultsArray[0] === 'string') {
      const combined = resultsArray.join('\n\n---\n\n');
      return exportSingleResult(combined);
    }
    
    // Fallback: use mode-based export from localStorage
    const mode = options.mode || 'all';
    return exportMultipleResults(mode);
  };
  
  // Helper: Export with custom filename
  async function exportSingleResultWithFilename(text, filename) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw first page header
    drawHeader(doc, 1, iconDataUrl);
    
    // Parse and write content
    const blocks = parseContent(text);
    
    if (blocks.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        content: 'No content available.'
      });
    } else {
      for (const block of blocks) {
        writer.writeBlock(block);
      }
    }
    
    // Finalize
    writer.finalize();
    
    // Save with custom filename
    doc.save(filename);
  }

  // Additional API aliases (extend existing YBG_PDF object)
  Object.assign(window.YBG_PDF, {
    exportResultToPDF: window.exportResultToPDF,
    exportAllResultsToPDF: window.exportAllResultsToPDF,
    exportLatestResult: () => exportMultipleResults('latest'),
    exportAllResults: () => exportMultipleResults('all')
  });

})();